---
layout: post
title: "面对对象（上）"
date: 2016-07-13 00:07:43 +0800
comments: true
categories: Java
---
# 面对对象 #

----------
类是一种自定义的**数据类型**，可以使用类来定义变量，使用类定义的变量都是**引用变量**

特征：封装、继承、多态

## 类和对象 ##
### 定义类 ###
- **类**：某一批对象的抽象
	- 成员：构造器、Field、方法
	
    > 成员之间定义的顺序没有任何影响，各成员之间可以相互调用，static修饰的成员不能访问没有static修饰的成员

		- field：用于定义给类或该类实例所包含的状态数据
		- 方法：定义该类或该类的实例的行为特征或者功能实现
		- 构造器：用于构造该类的实例，是一个类创建对象的根本途径
	
	>static修饰的成员表明它属于这个类本身，而不属于该类的单个实例 

- **对象**：一个具体存在的实体

### 对象、引用和指针 ###
类是引用类型，程序定义的Person类型的变量实际上是一个引用，他被存放在栈内存中，指向实际的Person对象，而真正的Person对象则存放在堆（heap）内存中。

### 对象的this引用 ###
**this**关键字总是指向**调用该方法**的**对象**，根据this出现的位置不同，this作为对象的默认引用有两种情形

- 构造器中引用该构造器正在初始化的对象
- 在方法中引用调用该方法的对象

**作用**：让类中的一个**方法**，访问该类里的另一个方法或Field

## 方法详解 ##
方法是类或对象的的行为特征的抽象，不能够独立存在，必须定义在类里

### 方法的所属性 ###
- 方法只能定义在类里
- 如果使用static修饰，则这个方法属于这个类，否则属于这个类的实例
- 永远不能独立执行方法，必须使用类或对象作为调用者

### 方法的参数传递机制 ###
**值传递**：将实际参数的值得副本传入方法内，而参数本身不会受到影响

### 方法重载 ###
**确定一个方法的三要素**

- 调用者，既可以是类，也可以是对象
- 方法名，方法的标识
- 形参列表

**方法重载的要求**：同一个类中方法名相同，参数列表不同（两同一不同）

## 成员变量和局部变量 ##
### 成员变量和局部变量 ###
成员变量：在类范围内定义的变量

- **类Field**：static修饰，作用域和这个类的生存范围相同
- **实例Field**：作用域与对应实例的生存范围相同

局部变量：在方法里定义的变量

- **形参**：作用域整个方法内有效
- **方法局部变量**：从定义该变量的地方生效，到该方法结束时失效
- **代码块局部变量**：从定义该变量的地方生效，到该代码块结束时失效

##隐藏和封装##
### 理解封装 ###
> 它是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作

**目的**

- 隐藏类的实现细节
- 让使用者只能同过事先预定的方法来访问数据，从而可以在该方法内加入控制逻辑限制对Field的不合理访问
- 可进行数据检查，保证对象信息的完整性
- 便于修改，提高代码的可维护性

**实现**

- 将对象的Field和实现细节隐藏起来，不允许外部直接访问
- 将方法暴露出来，让方法来控制这些Field进行安全的访问和操作

### 使用访问控制符 ###
**基本原则**

- 类里的绝大部分Field都应该使用private修饰，只有一些static修饰的、类似全局变量的Field，才能考虑使用public
- 如果这个类主要用作其他类的父类，该类里包含的大部分方法可能仅希望子类重写，而不想被外界直接调用，则应该使用protected修饰
- 希望暴露出来给其他类自由调用使用public修饰，构造器通常使用public


## 深入构造器 ##
构造器是一种特殊的方法，用于创建实例执行初始化
### 使用构造器进行初始化 ###
- 创建对象时执行初始化
- 提供了自定义的构造器，系统不再提供默认的构造器
- 通常构造器用public修饰，允许系统任何位置来创建对象

### 构造器的重载 ###
- 构造器重载和方法重载基本相似
- 构造器可以通过**this**调用本类中另个构造器的初始化代码，必须作为第一条语句

## 类的继承 ##
**三大特征之一、软件复用的重要手段、单继承**
### 继承的特点 ###
- 通过extends关键字来实现
- 子类不能获得父类的构造器
- Java类只能有一个**直接**父类
- Java.lang.Object类是所有类的父类

### 重写父类的方法 ###
方法重写是指子类包含与父类同名方法的现象，也可以称为方法覆盖（override）  
**“两同两小一大”规则**
- 两同：方法名相同，形参列表相同
- 两小：子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等
- 一大：子类方法的访问权限应比父类方法的访问权限更大或相等

覆盖方法和被覆盖的方法要么都是类方法，要么都是实力方法，如果父类方法具有private访问权限，则该方法对子类是隐藏的，无法重写
### 调用父类构造器 ###
子类不会获得父类的构造器，但子类构造器里可以调用父类构造器的初始化代码，使用super调用来完成，必须在构造器执行体的第一行。无论是否使用super调用来执行父类构造器的初始化代码，子类构造器总会调用父类构造器一次，有几种情况
- 子类构造器执行体的第一行使用super显示调用父类构造器
- 子类构造器执行体的第一行代码使用this显示调用本类中的重载的构造器
- 既没有super调用，也没有this调用，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器

当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行，并会回溯执行其父类构造器

## 多态 ##
Java引用变量有两个类型，一个是**编译时类型**，一个是**运行时类型**。编译时类型由**声明该变量时使用的类型**决定，运行时类型由**实际赋给该变量的对象**决定。多态即编译时类型与运行时类型不一致
### 多态性 ###
- Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换（向上转型）
- 当运行时调用引用变量的方法时，其方法行为总表现出子类方法的行为特征，而不是父类方法的行为特征
- 调用父类没有提供的方法时会出现编译出错
- 对象的field没有多态性

### 引用变量的强制类型转换 ###
引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法。  
强制类型转换时需要注意：
- 基本类型之间的转换只能在数值类型之间进行
- 引用类型之间的转换只能在具有继承关系的两个类型之间进行
- 在强制类型转换之前先用instanceof运算符判断是否可以成功转换，避免出现ClassCastException异常

### instanceof运算符 ###
instanceof运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类，用于判断前面的对象是否是后面的类，或者其子类，实现类的实例

## 继承与组合 ##
继承是实现类重用的重要手段，但继承带来的最大的坏处是破坏封装，相比之下，组合也是实现类重用的重要方式，并且提供了更好的封装性
### 使用继承的注意点 ###
- 子类扩展父类时，子类可以从父类继承得到Field和方法，如果访问权限允许，子类可以直接访问父类的Field和方法
- 子类直接访问父类的Field和方法，从而造成子类和父类的严重耦合

父类设计的规则
- 尽量隐藏父类的内部数据，将Field设置为private访问类型
- 不要让子类随意访问、修改父类的方法
	- 父类中那些辅助其他的工具方法，应该使用private修饰
	- 需要被外部调用，用public修饰，但不希望子类重写该方法，则可以使用final修饰符
	- 希望被子类重写，但不希望被其他类自由访问，则可以使用protected修饰
	- 尽量不要在父类构造器中调用将被子类重写的方法

派生子类的条件
- 子类需要额外增加属性，而不仅仅是属性值的改变
- 子类需要增加自己独有的行为方式

### 利用组合实现复用 ###

## 初始化代码 ##
### 使用初始化代码块 ###
初始化块是Java类中可出现的第四种成员（Field、方法、构造器），一个类可以有多个初始化块，相同类型的初始化块之间有顺序：前面定义的初始化块先执行，语法：

	[修饰符] {
		//初始化块的可执行性代码
		....
	}

初始化块的修饰符只能是static,使用static修饰的初始化块被称为静态初始化块，当创建Java对象时，系统总是先调用该类里定义的初始化块，静态初始化块是类相关的，系统将会在类初始化阶段执行静态初始化块，而不是创建对象时才执行